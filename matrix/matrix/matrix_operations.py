"""
Bobby Palmer, CSC 240, Project 2

~Operations~
This module contains all the Matrix Operations functions which can be performed on Matrix objects generated by the
Matrix class. By taking advantage of Python's ability to perform procedural and OOP programming I was able to abstract
the operations functions outside of a class structure which allows users to utilize them in a more intuitive manner
than if they had to be called as methods from within each Matrix instance.

When an illegal operation is attempted by the user the functions within raise exceptions detailing the failure.
"""
import copy
import math
from matrix.matrix import *


def scale(matrix, scalar):
    """
    Multiplies every value in the inputted matrix by the inputted scalar value, returns product as new matrix object.
    :param matrix: A matrix object.
    :param scalar: A numerical value, can be either float or integer.
    :return Matrix: A new matrix object of the scaled matrix.
    """
    if scalar == 0:
        raise ArithmeticError('This matrix cannot be scaled by zero.')

    matrix = copy.deepcopy(matrix)

    for row in range(matrix.rows):
        for column in range(matrix.columns):
            matrix.matrix[row][column] *= scalar

    return matrix


def add(matrix1, matrix2):
    """
    Computes the sum of two matrices, raises arithmetic error if operation is not allowed.
    :param matrix1: A matrix object.
    :param matrix2: A matrix object.
    :return Matrix: A new matrix object containing the sum of the inputted matrices.
    """
    if matrix1.rows != matrix2.rows or matrix1.columns != matrix2.columns:
        raise ArithmeticError('This operation cannot be performed on matrices of these dimensions.')

    newValues = []

    for row in range(matrix1.rows):
        for column in range(matrix1.columns):
            newValues.append(matrix1.matrix[row][column] + matrix2.matrix[row][column])

    return Matrix(matrix1.rows, matrix1.columns, newValues)


def multiply(matrix1, matrix2):
    """
    Computes the product of two matrices, raises arithmetic error if operation is not allowed.
    :param matrix1: A matrix object.
    :param matrix2: A matrix object.
    :return Matrix: A new matrix object containing the sum of the inputted matrices.
    """
    if matrix1.columns != matrix2.rows:
        raise ArithmeticError('This operation cannot be performed on matrices of these dimensions.')

    newData = []
    value = 0

    for row in range(matrix1.rows):
        for column in range(matrix2.columns):
            for counter in range(matrix2.rows):
                value += (matrix1.matrix[row][counter] * matrix2.matrix[counter][column])
            newData.append(value)
            value = 0

    return Matrix(matrix1.rows, matrix2.columns, newData)


def vectorDotProduct(matrix1, matrix2):
    """
    Computes the vector dot product of two matrices.
    :param matrix1: A matrix object.
    :param matrix2: A matrix object.
    :return product: A numerical value, which can be either a float or integer.
    """
    if matrix1.rows != matrix2.rows or matrix1.columns != matrix2.columns:
        raise ArithmeticError('This operation cannot be performed on matrices of these dimensions.')

    product = 0

    for row in range(matrix1.rows):
        for column in range(matrix2.columns):
            product += (matrix1.matrix[row][column] * matrix2.matrix[row][column])

    return product


def transpose(matrix):
    """
    Constructs the transpose matrix for the inputted matrix object.
    :param matrix: A matrix object.
    :return transposed: A new matrix object which is the transpose of the inputted matrix object.
    """
    newData = []

    for column in range(matrix.columns):
        for row in range(matrix.rows):
            newData.append(matrix.matrix[row][column])

    transposed = Matrix(matrix.columns, matrix.rows, newData)

    return transposed


def gaussJordan(matrix):
    """
    Computes the reduced row echelon form matrix for the inputted matrix using the Gauss-Jordan method.
    :param matrix: A matrix object.
    :return solvable: A boolean; if True the operation was allowed, if False the operation was unable to be performed.
    :return Matrix: A new Matrix object containing the reduced Matrix.
    """
    matrix = copy.deepcopy(matrix)
    presentRow, presentColumn, highestRow, highestRowValue = 0, 0, 0, 0

    while True:
        for row in range(presentRow, matrix.rows):
            if abs(matrix.matrix[row][presentColumn]) > highestRowValue:
                highestRowValue = abs(matrix.matrix[row][presentColumn])
                highestRow = row

        if highestRowValue == 0:
            return False, matrix

        if matrix.matrix[presentRow] != matrix.matrix[highestRow]:
            matrix.matrix[presentRow], matrix.matrix[highestRow] = matrix.matrix[highestRow], matrix.matrix[presentRow]
        highestRowValue = 0

        preserveValue = matrix.matrix[presentRow][presentColumn]
        for column in range(matrix.columns):
            matrix.matrix[presentRow][column] *= (1/preserveValue)

        for row in range(matrix.rows):
            preserveValue = matrix.matrix[row][presentColumn]
            if row != presentRow:
                for column in range(matrix.columns):
                    matrix.matrix[row][column] -= (matrix.matrix[presentRow][column] * preserveValue)

        presentRow += 1
        presentColumn += 1

        if presentColumn == matrix.columns or presentRow == matrix.rows:
            return True, matrix


def gaussianElimination(matrix):
    """
    Computes the row echelon form matrix for the inputted matrix using the Gaussian-Elimination method.
    :param matrix: A matrix object.
    :return solvable: A boolean; if True the operation was allowed, if False the operation was unable to be performed.
    :return Matrix: A new Matrix object containing the reduced Matrix.
    """
    matrix = copy.deepcopy(matrix)
    presentRow, presentColumn, highestRow, highestRowValue, swaps = 0, 0, 0, 0, 0

    while True:
        for row in range(presentRow, matrix.rows):
            if abs(matrix.matrix[row][presentColumn]) > highestRowValue:
                highestRowValue = abs(matrix.matrix[row][presentColumn])
                highestRow = row

        if highestRowValue == 0:
            return False, matrix, swaps

        if matrix.matrix[presentRow] != matrix.matrix[highestRow]:
            matrix.matrix[presentRow], matrix.matrix[highestRow] = matrix.matrix[highestRow], matrix.matrix[presentRow]
            swaps += 1

        highestRowValue = 0
        presentRow += 1

        for row in range(presentRow, matrix.rows):
            preserveValue = matrix.matrix[row][presentColumn]
            for column in range(presentColumn, matrix.columns):
                matrix.matrix[row][column] -= (preserveValue / matrix.matrix[presentRow-1][presentColumn] *
                                               matrix.matrix[presentRow-1][column])

        presentColumn += 1

        if presentColumn == matrix.columns or presentRow == matrix.rows:
            return True, matrix, swaps


def meanFinder(matrixList):
    """
    Calculates the mean of the inputted list of matrix objects.
    :param matrixList: A list of matrix objects.
    :return mean: A matrix object; the value of which is the mean of the matrix list.
    """
    meanZeroes = [0 for x in range(matrixList[0].rows * matrixList[0].columns)]
    mean = Matrix(matrixList[0].rows, matrixList[0].columns, meanZeroes)

    for matrix in matrixList:
        mean = add(mean, matrix)

    mean = scale(mean, (1/len(matrixList)))
    return mean


def covariance(matrixList, mean):
    """
    Calculates the covariance matrix for an inputted list of matrices.
    :param matrixList: A list of matrix objects.
    :param mean: A matrix object representing the mean of a list of matrices.
    :return covariance: A matrix object.
    """
    varianceList, covarianceList = [], []
    mean = scale(mean, -1)

    for matrix in matrixList:
        varianceList.append(add(matrix, mean))
    for matrix in varianceList:
        covarianceList.append(multiply(matrix, transpose(matrix)))

    covariance = meanFinder(covarianceList)
    return covariance


def determinant(matrix):
    """
    Computes the determinant of an inputted matrix using the Gauss reduction method.
    :param matrix: A matrix object.
    :return result: A numerical value, which can be either a float or integer.
    """
    solvable, matrix, swaps = gaussianElimination(matrix)
    columnCounter = 0
    result = 1

    if solvable is True:
        for row in range(matrix.rows):
            result *= matrix.matrix[row][columnCounter]
            columnCounter += 1
        return result * (-1)**swaps
    else:
        raise ArithmeticError('This operation cannot be performed on this matrix.')


def inverse(matrix):
    """
    Computes the inverse matrix for inputted matrix using the Gauss-Jordan elimination method.
    :param matrix: A matrix object.
    :return Matrix: A new Matrix object; the inverse matrix for the inputted matrix.
    """
    solvable, reducedMatrix = gaussJordan(matrix)
    newValues = []

    if solvable is True:
        for row in range(matrix.rows):
            for column in range(matrix.columns):
                newValues.append(matrix.matrix[row][column])
            for column in range(matrix.columns):
                newValues.append(reducedMatrix.matrix[row][column])
    else:
        raise ArithmeticError('This operation cannot be performed on this matrix.')

    inverseMatrix = Matrix(matrix.rows, matrix.columns*2, newValues)
    solvable, reducedMatrix = gaussJordan(inverseMatrix)
    newValues = []

    if solvable is True:
        for row in range(matrix.rows):
            for column in range(matrix.rows, reducedMatrix.columns):
                newValues.append(reducedMatrix.matrix[row][column])
        return Matrix(matrix.rows, matrix.columns, newValues)
    else:
        raise ArithmeticError('This operation cannot be performed on this matrix.')


def grader(value, meanMatrix, inverseMatrix, determinant, classSize, totalSize):
    """
    Uses naive bayes classification function to grade points.
    :param value: Matrix object to be graded.
    :param meanMatrix: Mean matrix of class.
    :param inverseMatrix: Class inverse matrix.
    :param determinant: Class determinant value.
    :param classSize: Size of class evaluated.
    :param totalSize: Total size of all values in all classes.
    :return grade: The result of the function; float.
    """
    meanTranspose, valueTranspose = transpose(meanMatrix), transpose(value)

    grade = multiply(multiply(add(valueTranspose, scale(meanTranspose, -1)), inverseMatrix),
                     add(value, scale(meanMatrix, -1)))
    grade = grade.matrix[0][0] * (-1/2)

    grade -= (1/2) * math.log(determinant)
    grade += math.log(classSize/totalSize)

    return grade


def conditionNumber(matrix, inverse):
    """
    Calculates the condition number for a Matrix object.
    :param matrix: A matrix object.
    :param inverse: The inverse matrix object of the inputted matrix.
    :return conditionNumber: Int or Float; the product of the largest sum of row values in the matrix and its inverse.
    """
    matrixMax, inverseMax, matrixCounter, inverseCounter = 0, 0, 0, 0

    for row in range(matrix.rows):
        for column in range(matrix.columns):
            matrixCounter += abs(matrix.matrix[row][column])
            inverseCounter += abs(inverse.matrix[row][column])
        if matrixCounter > matrixMax:
            matrixMax = matrixCounter
        if inverseCounter > inverseMax:
            inverseMax = inverseCounter
        matrixCounter, inverseCounter = 0, 0

    return matrixMax * inverseMax


def trace(matrix):
    """
    Computes the trace of the inputted matrix.
    :param matrix: A matrix object.
    :return: The trace.
    """
    if matrix.rows != matrix.columns:
        raise ArithmeticError('This operation cannot be performed on a matrix of these dimensions.')

    count, value = 0, 0

    for row in range(matrix.rows):
        value += matrix.matrix[row][count]
        count += 1

    return value


def getIdentity(matrix):
    """
    Finds and returns an equivalent identity matrix.
    :param matrix: A matrix object.
    :return: The identity matrix.
    """
    newData = []
    count = 0

    for i in range(matrix.rows):
        for j in range(matrix.columns):
            if j == count:
                newData.append(1)
            else:
                newData.append(0)
        count += 1

    return Matrix(matrix.rows, matrix.columns, newData)


def findEigenvalue(matrix):
    """
    Computes eigenvalues for 2x2 matrices.
    :param matrix: A matrix object.
    :return: Two eigenvalues.
    """
    if matrix.rows != 2 and matrix.columns != 2:
        raise ArithmeticError('This operation cannot be performed on a matrix of these dimensions.')
    t = trace(matrix)
    d = determinant(matrix)

    return t/2 + (t**2 / 4 - d)**(1/2), t/2 - (t**2 / 4 - d)**(1/2)


def findEigenvector(matrix, eigenValue):
    """
    Computes an eigenvector for a 2x2 matrix.
    :param matrix: A matrix object.
    :param eigenValue: A double value eigenvalue.
    :return: The computed eigenvector.
    """
    matrix = add(matrix, scale(scale(getIdentity(matrix), eigenValue), -1))

    newData = [0, 0]
    newData[0] = matrix.matrix[1][1]
    newData[1] = (-1 * matrix.matrix[1][0])

    if newData[0] == 0 and newData[1] == 0:
        newData[0] = (-1 * matrix.matrix[0][1])
        newData[1] = matrix.matrix[0][0]

    return scale(Matrix(matrix.rows, 1, newData), 1/(math.sqrt(newData[0]**2 + newData[1]**2)))


def leverrier(matrix):
    """
    Utilized Leverrier's method to find the characteristic polynomial of the inputted matrix.
    :param matrix: A matrix object.
    :return: A string representation of the characteristic polynomial.
    """
    b = copy.deepcopy(matrix)
    a = -1 * trace(matrix)
    coefficients = [a]
    identity = getIdentity(matrix)

    for k in range(matrix.rows-1, 0, -1):
        b = multiply(matrix, add(b, scale(identity, a)))
        a = -1 * (trace(b) / (matrix.rows - k + 1))
        coefficients.append(a)

    solution = "The characteristic polynomial of this matrix is: \n" + "x^" + str(len(coefficients)) + " + "
    for i in range(len(coefficients)-1):
        solution += (str(coefficients[i]) + "x^" + str(len(coefficients)-i-1) + " + ")

    return solution + str(coefficients[len(coefficients)-1])


def powerMethod(matrix):
    """
    Uses the power method to estimate the largest eigenvalue of the inputted matrix.
    :param matrix: A matrix object.
    :return: The eigenvalue estimate.
    """
    m = 50

    xValues = [1 for x in range(matrix.rows)]
    x = Matrix(matrix.rows, 1, xValues)
    aX = multiply(matrix, x)

    max = None

    while m > 0:
        aX = multiply(matrix, aX)
        m -= 1

    x = powerHelper(aX)
    aX = multiply(matrix, x)

    num = dotProduct(aX, x)
    den = dotProduct(x, x)

    return num/den


def powerHelper(aX):
    """Power-method helper function."""
    eigenValue = aX.matrix[1][0]
    for i in range(aX.rows):
        if aX.matrix[i][0] < eigenValue:
            eigenValue = aX.matrix[i][0]

    eigenVector = scale(aX, (1/eigenValue))

    return eigenVector


def dotProduct(matrix1, matrix2):
    """Power-method helper function."""
    product = 0
    for row in range(matrix1.rows):
        product += matrix1.matrix[row][0] * matrix2.matrix[row][0]

    return product

